input {
	syslog {
		type => "syslog"
		port => 10514
	}
}

filter {
    if [host] == "10.1.1.1" { mutate { replace => { "type" => "firewall" } } }
    if [host] == "172.18.0.1" { mutate { replace => { "type" => "firewall" } } }
    if [host] == "10.1.1.99" { mutate { replace => { "type" => "radio" } } }
    if [host] == "10.1.1.167" { mutate { replace => { "type" => "radio" } } }
}

filter {
    grok {
        id => "message"
        match => { "message" => "%{GREEDYDATA:raw_message}" }
    }

    if [type] == "firewall" {
        grok {
            id => "edgerouter_split"
            match  => {
            "message" => "\[%{DATA:iptables.ubiquiti.rule_set}-%{DATA:iptables.ubiquiti.rule_number}-%{DATA:event.outcome}\]%{GREEDYDATA:iptables.text}"
           }
        }

        mutate {
            lowercase => [ "iptables.text" ]
            gsub => ["iptables.text", "= ", "=null "]
        }
     
        kv {
            id => "edgerouter_iptables"
            source => "iptables.text"
            target => "iptables.data"
        }

        mutate {
            gsub => [
                "[iptables.data][tos]", "0x", "",
                "[iptables.data][prec]", "0x", ""
            ]
        }

        mutate {
            rename => {
                "[iptables.data][in]" => "iptables.input_device"
                "[iptables.data][out]" => "iptables.output_device"
                "[iptables.data][mac]" => "iptables.input_mac"
                "[iptables.data][src]" => "source.ip"
                "[iptables.data][dst]" => "destination.ip"
                "[iptables.data][tos]" => "iptables.tos"
                "[iptables.data][prec]" => "iptables.precedence_bits"
                "[iptables.data][ttl]" => "iptables.ttl"
                "[iptables.data][id]" => "iptables.id"
                "[iptables.data][proto]" => "network.transport"
                "[iptables.data][spt]" => "source.port"
                "[iptables.data][dpt]" => "destination.port"
                "[iptables.data][len]" => "iptables.length"
                "[iptables.data][window]" => "iptables.tcp.window"
                "[iptables.data][seq]" => "iptables.icmp.seq"
                "[iptables.data][type]" => "iptables.icmp.type"
                "[iptables.data][code]" => "iptables.icmp.code"
            }	
        }
        
        mutate {
            id => "edgerouter_eventoutcome"
            gsub => [
                "event.outcome", "A", "allow",
                "event.outcome", "D", "deny"
            ]
        }

        geoip {
            source => "source.ip"
            target => "source.geo"
        }

        geoip {
            source => "destination.ip"
            target => "destination.geo"
        }

        date {
            match => ["timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss"]
            timezone => "Australia/Perth"
            remove_field => ["timestamp"]
        }
    }





    if [type] == "radio" {
        grok {
            match => { "message" => "<%{NUMBER:priv}>%{MONTH:month} %{NOTSPACE:day} %{TIME:time} %{WORD:hostname} %{SYSLOGPROG:process}: %{GREEDYDATA:logmessage}"}
        } 
        
        if [process] == "hostapd" {
            grok {
                match => { "logmessage" => "%{DATA:interface}: %{DATA:action} %{MAC:station}( %{DATA:procotol}:)?( %{GREEDYDATA:hostapd.message})?" }
            }
        }

        mutate {
            copy => { "logmessage" => "message" }
            remove_field => [ "logmessage" ]
        }
    }
}


output {

  loki {
    url => "${LOKI_URL}"
    username => "${LOKI_USERNAME}"
    password => "${LOKI_PASSWORD}"
  }


#    stdout {
#        codec => rubydebug
#    }
}
